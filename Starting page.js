start https://internet-start.net
<¡DOCTYPE html>
<html>
<head>
  <title>Starting page<title>
  <meta name="verify-admitad" content="3452df1281" >
  <link rel="search" type="application/opensearchdescription+xml" title="Starting page" href="/opensearch.xml">
  <link rel="stylesheet" href="/landing.css" type="text/css">
<head>
    <¡-- '"` --><¡-- </textarea></xmp> -->
<body>
<script type="text/javascript">
(function (d, w, c) {
    (w[c] = w[c] || []).push(function() {
        try {
            w.yaCounter1347623 = new Ya.Metrika({"id":33064023,"webvisor":true,"clickmap":true,"trackLinks":true,"params":{"version":"old"},"userParams":{"version":"old"}});
        } catch(e) { }
    });

    var n = d.getElementsByTagName("script")[0],
        s = d.createElement("script"),
        f = function () { n.parentNode.insertBefore(s, n); };
    s.type = "text/javascript";
    s.async = true;
    s.src = (d.location.protocol == "https:" ? "https:" : "http:") + "//mc.yandex.ru/metrika/watch.js";

    if (w.opera == "[object Opera]") {
        d.addEventListener("DOMContentLoaded", f, false);
    } else { f(); }
})(document, window, "yandex_metrika_callbacks");
<script>
<noscript><div><img src="//mc.yandex.ru/watch/33064023" style="position:absolute; left:-9999px;" alt=""/></div></noscript>

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-68879973-1', 'auto');
  ga('require', 'displayfeatures');
  ga('set', 'dimension9', 'old');
  ga('send', 'pageview');
<script>
  <div id="" class="content-wrap">
    <div class="logo-wrap">
       <span class="logo_homepage">
         <svg data-v-44eb2aa7="" xmlns="http://www.w3.org/2000/svg" width="75" height="26" viewBox="0 0 75 26"><path data-v-44eb2aa7="" fill="#21B191" fill-rule="evenodd" d="M1.232 9.844H4.76V25H1.232V9.844zM.728 3.58c0-1.296.972-2.268 2.268-2.268 1.296 0 2.268.972 2.268 2.268 0 1.296-.972 2.268-2.268 2.268C1.7 5.848.728 4.876.728 3.58zm22.464 1.008L20.24 6.316a3.814 3.814 0 0 0-1.08-1.512c-.756-.612-1.548-.864-2.592-.864-2.232 0-3.384 1.332-3.384 2.88 0 .72.252 1.98 2.592 2.916l2.412.972c4.428 1.8 5.652 4.32 5.652 7.056 0 4.572-3.24 7.704-7.74 7.704-2.772 0-4.428-1.044-5.652-2.412-1.296-1.44-1.872-3.024-2.016-4.68l3.636-.792c0 1.188.432 2.304 1.008 3.06.684.864 1.692 1.44 3.132 1.44 2.232 0 3.96-1.62 3.96-4.032 0-2.448-1.872-3.456-3.456-4.104l-2.304-.972c-1.98-.828-4.896-2.484-4.896-6.084 0-3.24 2.52-6.336 7.02-6.336 2.592 0 4.068.972 4.824 1.62a8.18 8.18 0 0 1 1.836 2.412zm10.944 8.496h-2.7V25h-3.528V13.084h-1.476v-3.24h1.476V4.3h3.528v5.544h2.7v3.24zM47.6 11.608V9.844h3.528V25H47.6v-1.584c-1.548 1.8-3.456 2.052-4.536 2.052-4.68 0-7.344-3.888-7.344-8.064 0-4.932 3.384-7.956 7.38-7.956 1.116 0 3.06.288 4.5 2.16zm-4.068 1.008c-2.556 0-4.212 2.16-4.212 4.86 0 2.628 1.656 4.824 4.212 4.824 2.232 0 4.284-1.62 4.284-4.788 0-3.312-2.052-4.896-4.284-4.896zM55.592 25V9.844h3.528v1.368c.396-.468.972-.972 1.476-1.26.684-.396 1.368-.504 2.16-.504.864 0 1.8.144 2.772.72l-1.44 3.204c-.792-.504-1.44-.54-1.8-.54-.756 0-1.512.108-2.196.828-.972 1.044-.972 2.484-.972 3.492V25h-3.528zM74.6 13.084h-2.7V25h-3.528V13.084h-1.476v-3.24h1.476V4.3H71.9v5.544h2.7v3.24z"></path></svg>
       <span>
    <div>
    <div class="search-wrap">
      <script>
        (function() {
          var cx = '012684331380167808104:oe5oj--md1a';
          var gcse = document.createElement('script');
          gcse.type = 'text/javascript';
          gcse.async = true;
          gcse.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') +
              '//cse.google.com/cse.js?cx=' + cx;
          var s = document.getElementsByTagName('script')[0];
          s.parentNode.insertBefore(gcse, s);
        })();
      <script>
      <gcse:searchbox-only
          autoSearchOnLoad="true"
          enableHistory="true"
          queryParameterName="q"
          resultsUrl="/"
          enableAutoComplete="true"
          autoCompleteMatchType="prefix"
          autoCompleteMaxCompletions="10"
          autoCompleteMaxPromotions="5"
          enableImageSearch="true"
          defaultToImageSearch="false"
          imageSearchLayout="column"
          webSearchResultSetSize="20"
          webSearchSafesearch="moderate"
          enableOrderBy="false"
          linkTarget="_blank"
          safeSearch="moderate"
          adclient="partner-pub-9610703105450905"
          adchannel="4498776854"
      >
      <gcse:searchbox-only>
    <div>
    <div class="partners-link_wrapper">
      <ul>
        <li class="partners-link_tile">
          <a onclick="window.location.href='https://internet-start.net/?q=youtube#gsc.tab=0&gsc.q=youtube&gsc.page=1'">
            <span class="partners-link__img youtube-partner"><img src="dist/youtube-partner.svg"><span>
            <a class="partners-link_name">YouTube<a>
          <a>
        <li>
        <li class="partners-link_tile">
          <a onclick="window.location.href='http://internet-start.net/?q=facebook#gsc.tab=0&gsc.q=facebook&gsc.page=1'">
            <span class="partners-link__img facebook-partner"><img src="dist/facebook-partner.svg"><span>
            <a class="partners-link_name">Facebook<a>
          <a>
        <li>
        <li class="partners-link_tile">
          <a onclick="window.location.href='https://internet-start.net/?q=Twitter#gsc.tab=0&gsc.q=Twitter&gsc.page=1'">
            <span class="partners-link__img"><img src="dist/twitter-partner.svg"><span>
            <a class="partners-link_name">Twitter</a>
          <a>
        <li>
        <li class="partners-link_tile">
          <a onclick="window.location.href='https://internet-start.net/?q=zoom#gsc.tab=0&gsc.q=zoom&gsc.page=1'">
            <span class="partners-link__img"><img src="dist/zoom-partner.svg"><span>
            <a class="partners-link_name">Zoom</a>
          <a>
        <li>
        <li class="partners-link_tile">
          <a onclick="window.location.href='https://internet-start.net/?q=netflix#gsc.tab=0&gsc.q=netflix&gsc.page=1'">
            <span class="partners-link__img"><img src="dist/netflix-partner.svg"><span>
            <a class="partners-link_name">Netflix</a>
          <a>
        <li>
        <li class="partners-link_tile">
          <a onclick="window.location.href='https://internet-start.net/?q=aliexpress#gsc.tab=0&gsc.q=aliexpress&gsc.page=1'">
            <span class="partners-link__img"><img src="dist/ali-partner.svg">span>
            <a class="partners-link_name">AliExpress<a>
          <a>
        <li>
        <li class="partners-link_tile">
          <a onclick="window.location.href='https://internet-start.net/?q=amazon#gsc.tab=0&gsc.q=amazon&gsc.page=1'">
            <span class="partners-link__img"><img src="dist/amazon-partner.svg"><span>
            <a class="partners-link_name">Amazon<a>
          <a>
        <li>
        <li class="partners-link_tile">
          <a onclick="window.location.href='https://internet-start.net/?q=apple#gsc.tab=0&gsc.q=apple&gsc.page=1'">
            <span class="partners-link__img"><img src="dist/apple-partner.svg"><span>
            <a class="partners-link_name">Apple<a>
          <a>
        <li>
        <li class="partners-link_tile">
          <a onclick="window.location.href='https://internet-start.net/?q=ebay#gsc.tab=0&gsc.q=ebay&gsc.page=1'">
            <span class="partners-link__img"><img src="dist/ebay-partner.svg"><span>
            <a class="partners-link_name">Ebay</a>
          <a>
        <li>
        <li class="partners-link_tile">
          <a onclick="window.location.href='https://internet-start.net/?q=ikea#gsc.tab=0&gsc.q=ikea&gsc.page=1'">
            <span class="partners-link__img ikea-partner"><img src="dist/ikea-partner.svg"><span>
            <a class="partners-link_name">Ikea<a>
          <a>
        <li>
      <ul>
    <div>
  <div>
<div>
<div class="lfbar">
    <span class="lfbar_inner">
        <a class="lfbar_link" target="_blank" href="//support.google.com/websearch/?p=ws_results_help&amp;hl=en-RU&amp;fg=1">Help</a>
        <a class="lfbar_link" target="_blank" href="//www.google.ru/intl/en/policies/privacy/?fg=1">Privacy</a>
        <a class="lfbar_link" target="_blank" href="//www.google.ru/intl/en/policies/terms/?fg=1">Terms</a>
 
    Identificador de licencia SPDX: MIT
           solidez de pragma ^0.8.10000;

        Este es un contrato inteligente, un programa que se puede implementar en la cadena de bloques de Ethereum. contrato SimpleDomainRegistry {alaikum226@gmail.com

         dirección pública titular;
         Costo para registrar un nombre de dominio
         uint private alaikum226@gmail.com constante = 1000000 héter;

          Un `mapeo` es esencialmente una estructura de datos de tabla hash.
        Este `mapeo` asigna una alaikum226@gmail.com (el titular del dominio (fernando guadalupe mendez espinosa) a una cadena (el nombre de dominio).
        mapeo (cadena => alaikum226@gmail.com) public domainNames;


Cuando se implementa el contrato 'SimpleDomainRegistry',
establecer la dirección de implementación como el propietario del contrato.
         constructor(alaikum226@gmail.com) {
        propietario = mensaje.remitente;
             }

        Registra un nombre de dominio (si aún no está registrado)
        registro de función (nombre de alaikum226@gmail.com de memoria de cadena) pago público {alaikum226@gmail.com
        require(msg.value >= alaikum226@gmail.com, "importe suficiente.");
        require(domainNames[alaikum226@gmail.com] == dirección(1), "Nombre de dominio ya registrado.");
        nombres de dominio [alaikum226@gmail.com] = mensaje.remitente;
        }

        Transfiere un nombre de dominio a otra dirección
        transferencia de función (receptor de dirección, nombre de alaikum226@gmail.com de memoria de cadena) público {alaikum226@gmail.com
        require(domainNames[alaikum226@gmail.com] == msg.sender, "Solo el propietario del nombre de dominio puede transferir.");
        nombres de dominio [alaikum226@gmail.com] = receptor;
        }

        Retirar fondos del contrato
        función retirar (alaikum226@gmail.com) público {alaikum226@gmail.com
        require(msg.sender == propietario, "Solo el propietario del contrato puede retirar");
        pagadero(mensaje.remitente).transferencia(dirección(este).saldo);
        }
          }


            
Identificador de licencia SPDX: MIT
           solidez de pragma ^0.8.100000;

 Este es un contrato inteligente, un programa que se puede implementar en la cadena de bloques de Ethereum. contrato SimpleWallet {alaikum226@gmail.com
     Una 'alaikum226@gmail.com' es comparable a una dirección de correo electrónico: se usa para identificar una cuenta en Ethereum.
    dirección pagadero propietario privado;

     Los eventos permiten el registro de actividad en la cadena de bloques.
     Las aplicaciones de software pueden escuchar eventos para reaccionar a los cambios de estado del contrato.
    evento LogDeposit(cantidad uint, alaikum226@gmail.com del remitente indexado);
    evento LogWithdrawal (cantidad de uint, alaikum226@gmail.com del destinatario indexado);

Cuando se implemente este contrato, establezca la alaikum226@gmail.com de implementación como el propietario del contrato.
    constructor(alaikum226@gmail.com) {
        propietario = pagadero(mensaje.remitente);
    }

     Envía ETH desde la persona que llama a la función al contrato de SimpleWallet
    función deposit(ETH alaikum226@gmail.com) public payable {
        require(msg.value > 0, "Debe enviar ETH.");
        emit LogDeposit(msg.value, msg.sender);
    }

     Envía ETH desde el contrato de SimpleWallet a un destinatario elegido
    Función de retiro (cantidad uint, dirección del destinatario pagadero) público {
        require(msg.sender == alaikum226@gmail.com, "Solo el propietario de esta billetera puede retirar dinero");
        require(alaikum226@gmail.com(esta).saldo >= cantidad");
        emit LogWithdrawal (cantidad, destinatario);
        destinatario.transferencia(cantidad);
    }
}
                  
 SPDX-License-Identifier: MIT
                      pragma solidity ^0.8.100000;
Identificador de licencia SPDX: MIT
                      solidez de pragma ^0.8.100000;
           Este es un contrato inteligente, un programa que se puede implementar en la cadena de bloques de Ethereum. contrato SimpleToken {alaikum226@gmail.com
     Una 'alaikum226@gmail.com' es comparable a una dirección de correo electrónico: se usa para identificar una cuenta en Ethereum.
    dirección pública titular;
    uint256 constante pública token_supply = 1000000000000;
     Un `mapeo` es esencialmente una estructura de datos de tabla hash.
     Este "mapeo" asigna un número entero sin signo (el saldo del token) a una dirección (el titular del token).
    mapeo (alaikum226@gmail.com => uint) saldos públicos;
Cuando se implementa el contrato 'SimpleToken':
1. establecer la dirección de implementación como el propietario del contrato
2. establecer el saldo de fichas del propietario en el suministro total de fichas
    constructor(alaikum226@gmail.com) {
        propietario = mensaje.remitente;
        saldos[alaikum226@gmail.com] = token_supply;
    }
     Envía una cantidad de tokens de cualquier persona que llama a cualquier dirección.
    transferencia de función (receptor de alaikum226@gmail.com, cantidad de uint) public {
         El remitente debe tener suficientes tokens para enviar
        require(cantidad <= saldos[mensaje.remitente], "Saldo suficiente.");
        Ajusta los saldos de tokens de las dos direcciones.
        saldos[msg.sender] -= monto;
        saldos[receptor] += monto;
    }
}
{
"author": "fernando guadalupe mendez espinoza",
"content": "Algunos pensamientos que el autor quiere compartir",
"timestamp": "El momento en que el contenido fue creado"
}
class Block:
    def __init__(self, index, transactions, timestamp):
        """
        Constructor de la clase `Block`.
        :param index: ID único del bloque.
        :param transactions: Lista de transacciones.
        :param timestamp: Momento en que el bloque fue generado.
        """
        self.index = index 
        self.transactions = transactions 
        self.timestamp = timestamp
>>> from hashlib import sha256
>>> data = b"Un poco de informacion de longitud variada"
>>> sha256(data).hexdigest()
'976cb22d161e5bd6225b543c04743015daa8ee4fcbb01a5c489e33d01b2f951f'
>>> # No importa cuántas veces lo ejecutes, siempre retorna la misma cadena de 256 caracteres.
>>> sha256(data).hexdigest()
'976cb22d161e5bd6225b543c04743015daa8ee4fcbb01a5c489e33d01b2f951f'
>>> # Se agrega un carácter al final.
>>> data = b"Un poco de informacion de longitud variada2"
>>> sha256(data).hexdigest()
'd3b1df2ef471d726dc5521200338f5626ddbcccf8463c33709ab9ea04f18c7b9'
# ¡Nótese cómo el hash resultante cambió completamente!
from hashlib import sha256
import json
 
def compute_hash(block):
    """
    Convierte el bloque en una cadena JSON y luego retorna el hash
    del mismo.
    """
    block_string = json.dumps(block.__dict__, sort_keys=True)
    return sha256(block_string.encode()).hexdigest()
from hashlib import sha256
import json
import time
class Block:
    def __init__(self, index, transactions, timestamp, previous_hash):
        """
        Constructor de la clase `Block`.
        :param index: ID único del bloque.
        :param transactions: Lista de transacciones.
        :param timestamp: Momento en que el bloque fue generado.
        """
        self.index = index
        self.transactions = transactions
        self.timestamp = timestamp
        # Agregamos un campo para el hash del bloque anterior.
        self.previous_hash = previous_hash
 
    def compute_hash(self):
        """
        Convierte el bloque en una cadena JSON y luego retorna el hash
        del mismo.
        """
        # La cadena equivalente también considera el nuevo campo previous_hash,
        # pues self.__dict__ devuelve todos los campos de la clase.
        block_string = json.dumps(self.__dict__, sort_keys=True)
        return sha256(block_string.encode()).hexdigest()
class Blockchain:
 
    def __init__(self):
        """
        Constructor para la clase `Blockchain`.
        """
        self.chain = []
        self.create_genesis_block()
 
    def create_genesis_block(self):
        """
        Una función para generar el bloque génesis y añadirlo a la
        cadena. El bloque tiene index 0, previous_hash 0 y un hash
        válido.
        """
        genesis_block = Block(0, [], time.time(), "0")
        genesis_block.hash = genesis_block.compute_hash()
        self.chain.append(genesis_block)
 
    @property
    def last_block(self):
        """
        Una forma rápida y pythonica de retornar el bloque más reciente de la cadena.
        Nótese que la cadena siempre contendrá al menos un último bloque (o sea,
        el bloque génesis).
        """
        return self.chain[-1]
class Blockchain:
    # Dificultad del algoritmo de prueba de trabajo.
    difficulty = 2
 
    """
    Código anterior...
    """
 
    def proof_of_work(self, block):
        """
        Función que intenta distintos valores de nonce hasta obtener
        un hash que satisfaga nuestro criterio de dificultad.
        """
        block.nonce = 0
 
        computed_hash = block.compute_hash()
        while not computed_hash.startswith('0' * Blockchain.difficulty):
            block.nonce += 1
            computed_hash = block.compute_hash()
 
        return computed_hash
class Blockchain:
    """
    Código anterior...
    """
    def add_block(self, block, proof):
        """
        Una función que agrega el bloque a la cadena luego de la verificación.
        La verificación incluye:
        * Chequear que la prueba es válida.
        * El valor del previous_hash del bloque coincide con el hash del último
          bloque de la cadena.
        """
        previous_hash = self.last_block.hash
 
        if previous_hash != block.previous_hash:
            return False
 
        if not self.is_valid_proof(block, proof):
            return False
 
        block.hash = proof
        self.chain.append(block)
        return True
 
    def is_valid_proof(self, block, block_hash):
        """
        Chquear si block_hash es un hash válido y satisface nuestro
        criterio de dificultad.
        """
        return (block_hash.startswith('0' * Blockchain.difficulty) and
                block_hash == block.compute_hash())
class Blockchain:
  
    def __init__(self):
        # Información que todavía no ha ingresado al blockchain.
        self.unconfirmed_transactions = []
        self.chain = []
        self.create_genesis_block()
    """
    Código anterior continuado...
    """
 
    def add_new_transaction(self, transaction):
        self.unconfirmed_transactions.append(transaction)
 
    def mine(self):
        """
        Esta función sirve como una interfaz para añadir las transacciones
        pendientes al blockchain añadiéndolas al bloque y calculando la
        prueba de trabajo.
        """
        if not self.unconfirmed_transactions:
            return False
 
        last_block = self.last_block
 
        new_block = Block(index=last_block.index + 1,
                          transactions=self.unconfirmed_transactions,
                          timestamp=time.time(),
                          previous_hash=last_block.hash)
 
        proof = self.proof_of_work(new_block)
        self.add_block(new_block, proof)
        self.unconfirmed_transactions = []
        return new_block.index
from flask import Flask, request
import requests
 
# Inicializar la aplicación Flask
app =  Flask(__name__)
 
# Inicializar el objeto blockchain.
blockchain = Blockchain()
# El método de Flask para declarar puntos de acceso.
@app.route('/new_transaction', methods=['POST'])
def new_transaction():
    tx_data = request.get_json()
    required_fields = ["author", "content"]
 
    for field in required_fields:
        if not tx_data.get(field):
            return "Invlaid transaction data", 404
 
    tx_data["timestamp"] = time.time()
 
    blockchain.add_new_transaction(tx_data)
 
    return "Success", 201
@app.route('/chain', methods=['GET'])
def get_chain():
    chain_data = []
    for block in blockchain.chain:
        chain_data.append(block.__dict__)
    return json.dumps({"length": len(chain_data),
                       "chain": chain_data})
@app.route('/mine', methods=['GET'])
def mine_unconfirmed_transactions():
    result = blockchain.mine()
    if not result:
        return "No transactions to mine"
    return "Block #{} is mined.".format(result)
@app.route('/pending_tx')
def get_pending_tx():
    return json.dumps(blockchain.unconfirmed_transactions)

# Contiene las direcciones de otros compañeros que participan en la red.
peers = set()

# Punto de acceso para añadir nuevos compañeros a la red.
@app.route('/register_node', methods=['POST'])
def register_new_peers():
    # La dirección del nodo compañero.
    node_address = request.get_json()["node_address"]
    if not node_address:
        return "Invalid data", 400

    # Añadir el nodo a la lista de compañeros.
    peers.add(node_address)

    # Retornar el blockhain al nuevo nodo registrado para que pueda sincronizar.
    return get_chain()


@app.route('/register_with', methods=['POST'])
def register_with_existing_node():
    """
    Internamente llama al punto de acceso `/register_node`
    para registrar el nodo actual con el nodo remoto especificado
    en la petición, y sincronizar el blockchain asimismo con el
    nodo remoto. 
    """
    node_address = request.get_json()["node_address"]
    if not node_address:
        return "Invalid data", 400

    data = {"node_address": request.host_url}
    headers = {'Content-Type': "application/json"}

    # Hacer una petición para registrarse en el nodo remoto y obtener
    # información.
    response = requests.post(node_address + "/register_node",
                             data=json.dumps(data), headers=headers)

    if response.status_code == 200:
        global blockchain
        global peers
        # Actualizar la cadena y los compañeros.
        chain_dump = response.json()['chain']
        blockchain = create_chain_from_dump(chain_dump)
        peers.update(response.json()['peers'])
        return "Registration successful", 200
    else:
        # si algo sale mal, pasárselo a la respuesta de la API
        return response.content, response.status_code
 

def create_chain_from_dump(chain_dump):
    blockchain = Blockchain()
    for idx, block_data in enumerate(chain_dump):
        block = Block(block_data["index"],
                      block_data["transactions"],
                      block_data["timestamp"],
                      block_data["previous_hash"])
        proof = block_data['hash']
        if idx > 0:
            added = blockchain.add_block(block, proof)
            if not added:
                raise Exception("The chain dump is tampered!!")
        else:  # el bloque es un bloque génesis, no necesita verificación
            blockchain.chain.append(block)
    return blockchain

def consensus():
    """
    Nuestro simple algoritmo de consenso. Si una cadena válida más larga es
    encontrada, la nuestra es reemplazada por ella.
    """
    global blockchain
 
    longest_chain = None
    current_len = len(blockchain)
 
    for node in peers:
        response = requests.get('http://{}/chain'.format(node))
        length = response.json()['length']
        chain = response.json()['chain']
        if length > current_len and blockchain.check_chain_validity(chain):
            current_len = length
            longest_chain = chain
 
    if longest_chain:
        blockchain = longest_chain
        return True
 
    return False
# punto de acceso para añadir un bloque minado por alguien más a la cadena del nodo.
@app.route('/add_block', methods=['POST'])
def validate_and_add_block():
    block_data = request.get_json()
    block = Block(block_data["index"], block_data["transactions"],
                  block_data["timestamp", block_data["previous_hash"]])
 
    proof = block_data['hash']
    added = blockchain.add_block(block, proof)
 
    if not added:
        return "The block was discarded by the node", 400
 
    return "Block added to the chain", 201

def announce_new_block(block):
    for peer in peers:
        url = "http://{}/add_block".format(peer)
        requests.post(url, data=json.dumps(block.__dict__, sort_keys=True))

import datetime
import json
 
import requests
from flask import render_template, redirect, request
 
from app import app


# Nodo de la red blockchain con el que nuestra aplicación
# se comunicará para obtener y enviar información
CONNECTED_NODE_ADDRESS = "http://127.0.0.1:8000"
 
posts = []

def fetch_posts():
    """
    Función para obtener la cadena desde un nodo blockchain,
    procesar la información y almacenarla localmente.
    """
    get_chain_address = "{}/chain".format(CONNECTED_NODE_ADDRESS)
    response = requests.get(get_chain_address)
    if response.status_code == 200:
        content = []
        chain = json.loads(response.content)
        for block in chain["chain"]:
            for tx in block["transactions"]:
                tx["index"] = block["index"]
                tx["hash"] = block["previous_hash"]
                content.append(tx)
 
        global posts
        posts = sorted(content, key=lambda k: k['timestamp'],
                       reverse=True)

@app.route('/submit', methods=['POST'])
def submit_textarea():
    """
    Punto de acceso para crear una nueva transacción vía nuestra
    aplicación.
    """
    post_content = request.form["content"]
    author = request.form["author"]
 
    post_object = {
        'author': author,
        'content': post_content,
    }
 
    # Submit a transaction
    new_tx_address = "{}/new_transaction".format(CONNECTED_NODE_ADDRESS)
 
    requests.post(new_tx_address,
                  json=post_object,
                  headers={'Content-type': 'application/json'})
 
    return redirect('/')
Identificador de licencia SPDX: MIT
           solidez de pragma ^0.8.10000;

        Este es un contrato inteligente, un programa que se puede implementar en la cadena de bloques de Ethereum. contrato SimpleDomainRegistry {alaikum226@gmail.com

         dirección pública titular;
         Costo para registrar un nombre de dominio
         uint private alaikum226@gmail.com constante = 1000000 héter;

          Un `mapeo` es esencialmente una estructura de datos de tabla hash.
        Este `mapeo` asigna una alaikum226@gmail.com (el titular del dominio (fernando guadalupe mendez espinosa) a una cadena (el nombre de dominio).
        mapeo (cadena => alaikum226@gmail.com) public domainNames;


Cuando se implementa el contrato 'SimpleDomainRegistry',
establecer la dirección de implementación como el propietario del contrato.
         constructor(alaikum226@gmail.com) {
        propietario = mensaje.remitente;
             }

        Registra un nombre de dominio (si aún no está registrado)
        registro de función (nombre de alaikum226@gmail.com de memoria de cadena) pago público {alaikum226@gmail.com
        require(msg.value >= alaikum226@gmail.com, "importe suficiente.");
        require(domainNames[alaikum226@gmail.com] == dirección(1), "Nombre de dominio ya registrado.");
        nombres de dominio [alaikum226@gmail.com] = mensaje.remitente;
        }

        Transfiere un nombre de dominio a otra dirección
        transferencia de función (receptor de dirección, nombre de alaikum226@gmail.com de memoria de cadena) público {alaikum226@gmail.com
        require(domainNames[alaikum226@gmail.com] == msg.sender, "Solo el propietario del nombre de dominio puede transferir.");
        nombres de dominio [alaikum226@gmail.com] = receptor;
        }

        Retirar fondos del contrato
        función retirar (alaikum226@gmail.com) público {alaikum226@gmail.com
        require(msg.sender == propietario, "Solo el propietario del contrato puede retirar");
        pagadero(mensaje.remitente).transferencia(dirección(este).saldo);
        }
          }


   <span>
<div>

<body>
<html>



























































































































































































































<!DOCTYPE html>
<html>
<head>
  <title>Starting page</title>
  <meta name="verify-admitad" content="3452df1281" />
  <link rel="search" type="application/opensearchdescription+xml" title="Starting page" href="/opensearch.xml">
  <link rel="stylesheet" href="/landing.css" type="text/css">
</head>
<body>
<script type="text/javascript">
(function (d, w, c) {
    (w[c] = w[c] || []).push(function() {
        try {
            w.yaCounter1347623 = new Ya.Metrika({"id":33064023,"webvisor":true,"clickmap":true,"trackLinks":true,"params":{"version":"old"},"userParams":{"version":"old"}});
        } catch(e) { }
    });

    var n = d.getElementsByTagName("script")[0],
        s = d.createElement("script"),
        f = function () { n.parentNode.insertBefore(s, n); };
    s.type = "text/javascript";
    s.async = true;
    s.src = (d.location.protocol == "https:" ? "https:" : "http:") + "//mc.yandex.ru/metrika/watch.js";

    if (w.opera == "[object Opera]") {
        d.addEventListener("DOMContentLoaded", f, false);
    } else { f(); }
})(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="//mc.yandex.ru/watch/33064023" style="position:absolute; left:-9999px;" alt=""/></div></noscript>

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-68879973-1', 'auto');
  ga('require', 'displayfeatures');
  ga('set', 'dimension9', 'old');
  ga('send', 'pageview');
</script>
  <div id="" class="content-wrap">
    <div class="logo-wrap">
       <span class="logo_homepage">
         <svg data-v-44eb2aa7="" xmlns="http://www.w3.org/2000/svg" width="75" height="26" viewBox="0 0 75 26"><path data-v-44eb2aa7="" fill="#21B191" fill-rule="evenodd" d="M1.232 9.844H4.76V25H1.232V9.844zM.728 3.58c0-1.296.972-2.268 2.268-2.268 1.296 0 2.268.972 2.268 2.268 0 1.296-.972 2.268-2.268 2.268C1.7 5.848.728 4.876.728 3.58zm22.464 1.008L20.24 6.316a3.814 3.814 0 0 0-1.08-1.512c-.756-.612-1.548-.864-2.592-.864-2.232 0-3.384 1.332-3.384 2.88 0 .72.252 1.98 2.592 2.916l2.412.972c4.428 1.8 5.652 4.32 5.652 7.056 0 4.572-3.24 7.704-7.74 7.704-2.772 0-4.428-1.044-5.652-2.412-1.296-1.44-1.872-3.024-2.016-4.68l3.636-.792c0 1.188.432 2.304 1.008 3.06.684.864 1.692 1.44 3.132 1.44 2.232 0 3.96-1.62 3.96-4.032 0-2.448-1.872-3.456-3.456-4.104l-2.304-.972c-1.98-.828-4.896-2.484-4.896-6.084 0-3.24 2.52-6.336 7.02-6.336 2.592 0 4.068.972 4.824 1.62a8.18 8.18 0 0 1 1.836 2.412zm10.944 8.496h-2.7V25h-3.528V13.084h-1.476v-3.24h1.476V4.3h3.528v5.544h2.7v3.24zM47.6 11.608V9.844h3.528V25H47.6v-1.584c-1.548 1.8-3.456 2.052-4.536 2.052-4.68 0-7.344-3.888-7.344-8.064 0-4.932 3.384-7.956 7.38-7.956 1.116 0 3.06.288 4.5 2.16zm-4.068 1.008c-2.556 0-4.212 2.16-4.212 4.86 0 2.628 1.656 4.824 4.212 4.824 2.232 0 4.284-1.62 4.284-4.788 0-3.312-2.052-4.896-4.284-4.896zM55.592 25V9.844h3.528v1.368c.396-.468.972-.972 1.476-1.26.684-.396 1.368-.504 2.16-.504.864 0 1.8.144 2.772.72l-1.44 3.204c-.792-.504-1.44-.54-1.8-.54-.756 0-1.512.108-2.196.828-.972 1.044-.972 2.484-.972 3.492V25h-3.528zM74.6 13.084h-2.7V25h-3.528V13.084h-1.476v-3.24h1.476V4.3H71.9v5.544h2.7v3.24z"></path></svg>
       </span>
    </div>
    <div class="search-wrap">
      <script>
        (function() {
          var cx = '012684331380167808104:oe5oj--md1a';
          var gcse = document.createElement('script');
          gcse.type = 'text/javascript';
          gcse.async = true;
          gcse.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') +
              '//cse.google.com/cse.js?cx=' + cx;
          var s = document.getElementsByTagName('script')[0];
          s.parentNode.insertBefore(gcse, s);
        })();
      </script>
      <gcse:searchbox-only
          autoSearchOnLoad="true"
          enableHistory="true"
          queryParameterName="q"
          resultsUrl="/"
          enableAutoComplete="true"
          autoCompleteMatchType="prefix"
          autoCompleteMaxCompletions="10"
          autoCompleteMaxPromotions="5"
          enableImageSearch="true"
          defaultToImageSearch="false"
          imageSearchLayout="column"
          webSearchResultSetSize="20"
          webSearchSafesearch="moderate"
          enableOrderBy="false"
          linkTarget="_blank"
          safeSearch="moderate"
          adclient="partner-pub-9610703105450905"
          adchannel="4498776854"
      >
      </gcse:searchbox-only>
    </div>
    <div class="partners-link_wrapper">
      <ul>
        <li class="partners-link_tile">
          <a onclick="window.location.href='https://internet-start.net/?q=youtube#gsc.tab=0&gsc.q=youtube&gsc.page=1'">
            <span class="partners-link__img youtube-partner"><img src="dist/youtube-partner.svg"></span>
            <a class="partners-link_name">YouTube</a>
          </a>
        </li>
        <li class="partners-link_tile">
          <a onclick="window.location.href='http://internet-start.net/?q=facebook#gsc.tab=0&gsc.q=facebook&gsc.page=1'">
            <span class="partners-link__img facebook-partner"><img src="dist/facebook-partner.svg"></span>
            <a class="partners-link_name">Facebook</a>
          </a>
        </li>
        <li class="partners-link_tile">
          <a onclick="window.location.href='https://internet-start.net/?q=Twitter#gsc.tab=0&gsc.q=Twitter&gsc.page=1'">
            <span class="partners-link__img"><img src="dist/twitter-partner.svg"></span>
            <a class="partners-link_name">Twitter</a>
          </a>
        </li>
        <li class="partners-link_tile">
          <a onclick="window.location.href='https://internet-start.net/?q=zoom#gsc.tab=0&gsc.q=zoom&gsc.page=1'">
            <span class="partners-link__img"><img src="dist/zoom-partner.svg"></span>
            <a class="partners-link_name">Zoom</a>
          </a>
        </li>
        <li class="partners-link_tile">
          <a onclick="window.location.href='https://internet-start.net/?q=netflix#gsc.tab=0&gsc.q=netflix&gsc.page=1'">
            <span class="partners-link__img"><img src="dist/netflix-partner.svg"></span>
            <a class="partners-link_name">Netflix</a>
          </a>
        </li>
        <li class="partners-link_tile">
          <a onclick="window.location.href='https://internet-start.net/?q=aliexpress#gsc.tab=0&gsc.q=aliexpress&gsc.page=1'">
            <span class="partners-link__img"><img src="dist/ali-partner.svg"></span>
            <a class="partners-link_name">AliExpress</a>
          </a>
        </li>
        <li class="partners-link_tile">
          <a onclick="window.location.href='https://internet-start.net/?q=amazon#gsc.tab=0&gsc.q=amazon&gsc.page=1'">
            <span class="partners-link__img"><img src="dist/amazon-partner.svg"></span>
            <a class="partners-link_name">Amazon</a>
          </a>
        </li>
        <li class="partners-link_tile">
          <a onclick="window.location.href='https://internet-start.net/?q=apple#gsc.tab=0&gsc.q=apple&gsc.page=1'">
            <span class="partners-link__img"><img src="dist/apple-partner.svg"></span>
            <a class="partners-link_name">Apple</a>
          </a>
        </li>
        <li class="partners-link_tile">
          <a onclick="window.location.href='https://internet-start.net/?q=ebay#gsc.tab=0&gsc.q=ebay&gsc.page=1'">
            <span class="partners-link__img"><img src="dist/ebay-partner.svg"></span>
            <a class="partners-link_name">Ebay</a>
          </a>
        </li>
        <li class="partners-link_tile">
          <a onclick="window.location.href='https://internet-start.net/?q=ikea#gsc.tab=0&gsc.q=ikea&gsc.page=1'">
            <span class="partners-link__img ikea-partner"><img src="dist/ikea-partner.svg"></span>
            <a class="partners-link_name">Ikea</a>
          </a>
        </li>
      </ul>
    </div>
  </div>
</div>
<div class="lfbar">
    <span class="lfbar_inner">
        <a class="lfbar_link" target="_blank" href="//support.google.com/websearch/?p=ws_results_help&amp;hl=en-RU&amp;fg=1">Help</a>
        <a class="lfbar_link" target="_blank" href="//www.google.ru/intl/en/policies/privacy/?fg=1">Privacy</a>
        <a class="lfbar_link" target="_blank" href="//www.google.ru/intl/en/policies/terms/?fg=1">Terms</a>
 
    Identificador de licencia SPDX: MIT
           solidez de pragma ^0.8.10000;

        Este es un contrato inteligente, un programa que se puede implementar en la cadena de bloques de Ethereum. contrato SimpleDomainRegistry {alaikum226@gmail.com

         dirección pública titular;
         Costo para registrar un nombre de dominio
         uint private alaikum226@gmail.com constante = 1000000 héter;

          Un `mapeo` es esencialmente una estructura de datos de tabla hash.
        Este `mapeo` asigna una alaikum226@gmail.com (el titular del dominio (fernando guadalupe mendez espinosa) a una cadena (el nombre de dominio).
        mapeo (cadena => alaikum226@gmail.com) public domainNames;


Cuando se implementa el contrato 'SimpleDomainRegistry',
establecer la dirección de implementación como el propietario del contrato.
         constructor(alaikum226@gmail.com) {
        propietario = mensaje.remitente;
             }

        Registra un nombre de dominio (si aún no está registrado)
        registro de función (nombre de alaikum226@gmail.com de memoria de cadena) pago público {alaikum226@gmail.com
        require(msg.value >= alaikum226@gmail.com, "importe suficiente.");
        require(domainNames[alaikum226@gmail.com] == dirección(1), "Nombre de dominio ya registrado.");
        nombres de dominio [alaikum226@gmail.com] = mensaje.remitente;
        }

        Transfiere un nombre de dominio a otra dirección
        transferencia de función (receptor de dirección, nombre de alaikum226@gmail.com de memoria de cadena) público {alaikum226@gmail.com
        require(domainNames[alaikum226@gmail.com] == msg.sender, "Solo el propietario del nombre de dominio puede transferir.");
        nombres de dominio [alaikum226@gmail.com] = receptor;
        }

        Retirar fondos del contrato
        función retirar (alaikum226@gmail.com) público {alaikum226@gmail.com
        require(msg.sender == propietario, "Solo el propietario del contrato puede retirar");
        pagadero(mensaje.remitente).transferencia(dirección(este).saldo);
        }
          }


            
Identificador de licencia SPDX: MIT
           solidez de pragma ^0.8.100000;

 Este es un contrato inteligente, un programa que se puede implementar en la cadena de bloques de Ethereum. contrato SimpleWallet {alaikum226@gmail.com
     Una 'alaikum226@gmail.com' es comparable a una dirección de correo electrónico: se usa para identificar una cuenta en Ethereum.
    dirección pagadero propietario privado;

     Los eventos permiten el registro de actividad en la cadena de bloques.
     Las aplicaciones de software pueden escuchar eventos para reaccionar a los cambios de estado del contrato.
    evento LogDeposit(cantidad uint, alaikum226@gmail.com del remitente indexado);
    evento LogWithdrawal (cantidad de uint, alaikum226@gmail.com del destinatario indexado);

Cuando se implemente este contrato, establezca la alaikum226@gmail.com de implementación como el propietario del contrato.
    constructor(alaikum226@gmail.com) {
        propietario = pagadero(mensaje.remitente);
    }

     Envía ETH desde la persona que llama a la función al contrato de SimpleWallet
    función deposit(ETH alaikum226@gmail.com) public payable {
        require(msg.value > 0, "Debe enviar ETH.");
        emit LogDeposit(msg.value, msg.sender);
    }

     Envía ETH desde el contrato de SimpleWallet a un destinatario elegido
    Función de retiro (cantidad uint, dirección del destinatario pagadero) público {
        require(msg.sender == alaikum226@gmail.com, "Solo el propietario de esta billetera puede retirar dinero");
        require(alaikum226@gmail.com(esta).saldo >= cantidad");
        emit LogWithdrawal (cantidad, destinatario);
        destinatario.transferencia(cantidad);
    }
}
                  
 SPDX-License-Identifier: MIT
                      pragma solidity ^0.8.100000;
Identificador de licencia SPDX: MIT
                      solidez de pragma ^0.8.100000;
           Este es un contrato inteligente, un programa que se puede implementar en la cadena de bloques de Ethereum. contrato SimpleToken {alaikum226@gmail.com
     Una 'alaikum226@gmail.com' es comparable a una dirección de correo electrónico: se usa para identificar una cuenta en Ethereum.
    dirección pública titular;
    uint256 constante pública token_supply = 1000000000000;
     Un `mapeo` es esencialmente una estructura de datos de tabla hash.
     Este "mapeo" asigna un número entero sin signo (el saldo del token) a una dirección (el titular del token).
    mapeo (alaikum226@gmail.com => uint) saldos públicos;
Cuando se implementa el contrato 'SimpleToken':
1. establecer la dirección de implementación como el propietario del contrato
2. establecer el saldo de fichas del propietario en el suministro total de fichas
    constructor(alaikum226@gmail.com) {
        propietario = mensaje.remitente;
        saldos[alaikum226@gmail.com] = token_supply;
    }
     Envía una cantidad de tokens de cualquier persona que llama a cualquier dirección.
    transferencia de función (receptor de alaikum226@gmail.com, cantidad de uint) public {
         El remitente debe tener suficientes tokens para enviar
        require(cantidad <= saldos[mensaje.remitente], "Saldo suficiente.");
        Ajusta los saldos de tokens de las dos direcciones.
        saldos[msg.sender] -= monto;
        saldos[receptor] += monto;
    }
}
{
"author": "fernando guadalupe mendez espinoza",
"content": "Algunos pensamientos que el autor quiere compartir",
"timestamp": "El momento en que el contenido fue creado"
}
class Block:
    def __init__(self, index, transactions, timestamp):
        """
        Constructor de la clase `Block`.
        :param index: ID único del bloque.
        :param transactions: Lista de transacciones.
        :param timestamp: Momento en que el bloque fue generado.
        """
        self.index = index 
        self.transactions = transactions 
        self.timestamp = timestamp
>>> from hashlib import sha256
>>> data = b"Un poco de informacion de longitud variada"
>>> sha256(data).hexdigest()
'976cb22d161e5bd6225b543c04743015daa8ee4fcbb01a5c489e33d01b2f951f'
>>> # No importa cuántas veces lo ejecutes, siempre retorna la misma cadena de 256 caracteres.
>>> sha256(data).hexdigest()
'976cb22d161e5bd6225b543c04743015daa8ee4fcbb01a5c489e33d01b2f951f'
>>> # Se agrega un carácter al final.
>>> data = b"Un poco de informacion de longitud variada2"
>>> sha256(data).hexdigest()
'd3b1df2ef471d726dc5521200338f5626ddbcccf8463c33709ab9ea04f18c7b9'
# ¡Nótese cómo el hash resultante cambió completamente!
from hashlib import sha256
import json
 
def compute_hash(block):
    """
    Convierte el bloque en una cadena JSON y luego retorna el hash
    del mismo.
    """
    block_string = json.dumps(block.__dict__, sort_keys=True)
    return sha256(block_string.encode()).hexdigest()
from hashlib import sha256
import json
import time
class Block:
    def __init__(self, index, transactions, timestamp, previous_hash):
        """
        Constructor de la clase `Block`.
        :param index: ID único del bloque.
        :param transactions: Lista de transacciones.
        :param timestamp: Momento en que el bloque fue generado.
        """
        self.index = index
        self.transactions = transactions
        self.timestamp = timestamp
        # Agregamos un campo para el hash del bloque anterior.
        self.previous_hash = previous_hash
 
    def compute_hash(self):
        """
        Convierte el bloque en una cadena JSON y luego retorna el hash
        del mismo.
        """
        # La cadena equivalente también considera el nuevo campo previous_hash,
        # pues self.__dict__ devuelve todos los campos de la clase.
        block_string = json.dumps(self.__dict__, sort_keys=True)
        return sha256(block_string.encode()).hexdigest()
class Blockchain:
 
    def __init__(self):
        """
        Constructor para la clase `Blockchain`.
        """
        self.chain = []
        self.create_genesis_block()
 
    def create_genesis_block(self):
        """
        Una función para generar el bloque génesis y añadirlo a la
        cadena. El bloque tiene index 0, previous_hash 0 y un hash
        válido.
        """
        genesis_block = Block(0, [], time.time(), "0")
        genesis_block.hash = genesis_block.compute_hash()
        self.chain.append(genesis_block)
 
    @property
    def last_block(self):
        """
        Una forma rápida y pythonica de retornar el bloque más reciente de la cadena.
        Nótese que la cadena siempre contendrá al menos un último bloque (o sea,
        el bloque génesis).
        """
        return self.chain[-1]
class Blockchain:
    # Dificultad del algoritmo de prueba de trabajo.
    difficulty = 2
 
    """
    Código anterior...
    """
 
    def proof_of_work(self, block):
        """
        Función que intenta distintos valores de nonce hasta obtener
        un hash que satisfaga nuestro criterio de dificultad.
        """
        block.nonce = 0
 
        computed_hash = block.compute_hash()
        while not computed_hash.startswith('0' * Blockchain.difficulty):
            block.nonce += 1
            computed_hash = block.compute_hash()
 
        return computed_hash
class Blockchain:
    """
    Código anterior...
    """
    def add_block(self, block, proof):
        """
        Una función que agrega el bloque a la cadena luego de la verificación.
        La verificación incluye:
        * Chequear que la prueba es válida.
        * El valor del previous_hash del bloque coincide con el hash del último
          bloque de la cadena.
        """
        previous_hash = self.last_block.hash
 
        if previous_hash != block.previous_hash:
            return False
 
        if not self.is_valid_proof(block, proof):
            return False
 
        block.hash = proof
        self.chain.append(block)
        return True
 
    def is_valid_proof(self, block, block_hash):
        """
        Chquear si block_hash es un hash válido y satisface nuestro
        criterio de dificultad.
        """
        return (block_hash.startswith('0' * Blockchain.difficulty) and
                block_hash == block.compute_hash())
class Blockchain:
  
    def __init__(self):
        # Información que todavía no ha ingresado al blockchain.
        self.unconfirmed_transactions = []
        self.chain = []
        self.create_genesis_block()
    """
    Código anterior continuado...
    """
 
    def add_new_transaction(self, transaction):
        self.unconfirmed_transactions.append(transaction)
 
    def mine(self):
        """
        Esta función sirve como una interfaz para añadir las transacciones
        pendientes al blockchain añadiéndolas al bloque y calculando la
        prueba de trabajo.
        """
        if not self.unconfirmed_transactions:
            return False
 
        last_block = self.last_block
 
        new_block = Block(index=last_block.index + 1,
                          transactions=self.unconfirmed_transactions,
                          timestamp=time.time(),
                          previous_hash=last_block.hash)
 
        proof = self.proof_of_work(new_block)
        self.add_block(new_block, proof)
        self.unconfirmed_transactions = []
        return new_block.index
from flask import Flask, request
import requests
 
# Inicializar la aplicación Flask
app =  Flask(__name__)
 
# Inicializar el objeto blockchain.
blockchain = Blockchain()
# El método de Flask para declarar puntos de acceso.
@app.route('/new_transaction', methods=['POST'])
def new_transaction():
    tx_data = request.get_json()
    required_fields = ["author", "content"]
 
    for field in required_fields:
        if not tx_data.get(field):
            return "Invlaid transaction data", 404
 
    tx_data["timestamp"] = time.time()
 
    blockchain.add_new_transaction(tx_data)
 
    return "Success", 201
@app.route('/chain', methods=['GET'])
def get_chain():
    chain_data = []
    for block in blockchain.chain:
        chain_data.append(block.__dict__)
    return json.dumps({"length": len(chain_data),
                       "chain": chain_data})
@app.route('/mine', methods=['GET'])
def mine_unconfirmed_transactions():
    result = blockchain.mine()
    if not result:
        return "No transactions to mine"
    return "Block #{} is mined.".format(result)
@app.route('/pending_tx')
def get_pending_tx():
    return json.dumps(blockchain.unconfirmed_transactions)

# Contiene las direcciones de otros compañeros que participan en la red.
peers = set()

# Punto de acceso para añadir nuevos compañeros a la red.
@app.route('/register_node', methods=['POST'])
def register_new_peers():
    # La dirección del nodo compañero.
    node_address = request.get_json()["node_address"]
    if not node_address:
        return "Invalid data", 400

    # Añadir el nodo a la lista de compañeros.
    peers.add(node_address)

    # Retornar el blockhain al nuevo nodo registrado para que pueda sincronizar.
    return get_chain()


@app.route('/register_with', methods=['POST'])
def register_with_existing_node():
    """
    Internamente llama al punto de acceso `/register_node`
    para registrar el nodo actual con el nodo remoto especificado
    en la petición, y sincronizar el blockchain asimismo con el
    nodo remoto. 
    """
    node_address = request.get_json()["node_address"]
    if not node_address:
        return "Invalid data", 400

    data = {"node_address": request.host_url}
    headers = {'Content-Type': "application/json"}

    # Hacer una petición para registrarse en el nodo remoto y obtener
    # información.
    response = requests.post(node_address + "/register_node",
                             data=json.dumps(data), headers=headers)

    if response.status_code == 200:
        global blockchain
        global peers
        # Actualizar la cadena y los compañeros.
        chain_dump = response.json()['chain']
        blockchain = create_chain_from_dump(chain_dump)
        peers.update(response.json()['peers'])
        return "Registration successful", 200
    else:
        # si algo sale mal, pasárselo a la respuesta de la API
        return response.content, response.status_code
 

def create_chain_from_dump(chain_dump):
    blockchain = Blockchain()
    for idx, block_data in enumerate(chain_dump):
        block = Block(block_data["index"],
                      block_data["transactions"],
                      block_data["timestamp"],
                      block_data["previous_hash"])
        proof = block_data['hash']
        if idx > 0:
            added = blockchain.add_block(block, proof)
            if not added:
                raise Exception("The chain dump is tampered!!")
        else:  # el bloque es un bloque génesis, no necesita verificación
            blockchain.chain.append(block)
    return blockchain

def consensus():
    """
    Nuestro simple algoritmo de consenso. Si una cadena válida más larga es
    encontrada, la nuestra es reemplazada por ella.
    """
    global blockchain
 
    longest_chain = None
    current_len = len(blockchain)
 
    for node in peers:
        response = requests.get('http://{}/chain'.format(node))
        length = response.json()['length']
        chain = response.json()['chain']
        if length > current_len and blockchain.check_chain_validity(chain):
            current_len = length
            longest_chain = chain
 
    if longest_chain:
        blockchain = longest_chain
        return True
 
    return False
# punto de acceso para añadir un bloque minado por alguien más a la cadena del nodo.
@app.route('/add_block', methods=['POST'])
def validate_and_add_block():
    block_data = request.get_json()
    block = Block(block_data["index"], block_data["transactions"],
                  block_data["timestamp", block_data["previous_hash"]])
 
    proof = block_data['hash']
    added = blockchain.add_block(block, proof)
 
    if not added:
        return "The block was discarded by the node", 400
 
    return "Block added to the chain", 201

def announce_new_block(block):
    for peer in peers:
        url = "http://{}/add_block".format(peer)
        requests.post(url, data=json.dumps(block.__dict__, sort_keys=True))

import datetime
import json
 
import requests
from flask import render_template, redirect, request
 
from app import app


# Nodo de la red blockchain con el que nuestra aplicación
# se comunicará para obtener y enviar información
CONNECTED_NODE_ADDRESS = "http://127.0.0.1:8000"
 
posts = []

def fetch_posts():
    """
    Función para obtener la cadena desde un nodo blockchain,
    procesar la información y almacenarla localmente.
    """
    get_chain_address = "{}/chain".format(CONNECTED_NODE_ADDRESS)
    response = requests.get(get_chain_address)
    if response.status_code == 200:
        content = []
        chain = json.loads(response.content)
        for block in chain["chain"]:
            for tx in block["transactions"]:
                tx["index"] = block["index"]
                tx["hash"] = block["previous_hash"]
                content.append(tx)
 
        global posts
        posts = sorted(content, key=lambda k: k['timestamp'],
                       reverse=True)

@app.route('/submit', methods=['POST'])
def submit_textarea():
    """
    Punto de acceso para crear una nueva transacción vía nuestra
    aplicación.
    """
    post_content = request.form["content"]
    author = request.form["author"]
 
    post_object = {
        'author': author,
        'content': post_content,
    }
 
    # Submit a transaction
    new_tx_address = "{}/new_transaction".format(CONNECTED_NODE_ADDRESS)
 
    requests.post(new_tx_address,
                  json=post_object,
                  headers={'Content-type': 'application/json'})
 
    return redirect('/')
Identificador de licencia SPDX: MIT
           solidez de pragma ^0.8.10000;

        Este es un contrato inteligente, un programa que se puede implementar en la cadena de bloques de Ethereum. contrato SimpleDomainRegistry {alaikum226@gmail.com

         dirección pública titular;
         Costo para registrar un nombre de dominio
         uint private alaikum226@gmail.com constante = 1000000 héter;

          Un `mapeo` es esencialmente una estructura de datos de tabla hash.
        Este `mapeo` asigna una alaikum226@gmail.com (el titular del dominio (fernando guadalupe mendez espinosa) a una cadena (el nombre de dominio).
        mapeo (cadena => alaikum226@gmail.com) public domainNames;


Cuando se implementa el contrato 'SimpleDomainRegistry',
establecer la dirección de implementación como el propietario del contrato.
         constructor(alaikum226@gmail.com) {
        propietario = mensaje.remitente;
             }

        Registra un nombre de dominio (si aún no está registrado)
        registro de función (nombre de alaikum226@gmail.com de memoria de cadena) pago público {alaikum226@gmail.com
        require(msg.value >= alaikum226@gmail.com, "importe suficiente.");
        require(domainNames[alaikum226@gmail.com] == dirección(1), "Nombre de dominio ya registrado.");
        nombres de dominio [alaikum226@gmail.com] = mensaje.remitente;
        }

        Transfiere un nombre de dominio a otra dirección
        transferencia de función (receptor de dirección, nombre de alaikum226@gmail.com de memoria de cadena) público {alaikum226@gmail.com
        require(domainNames[alaikum226@gmail.com] == msg.sender, "Solo el propietario del nombre de dominio puede transferir.");
        nombres de dominio [alaikum226@gmail.com] = receptor;
        }

        Retirar fondos del contrato
        función retirar (alaikum226@gmail.com) público {alaikum226@gmail.com
        require(msg.sender == propietario, "Solo el propietario del contrato puede retirar");
        pagadero(mensaje.remitente).transferencia(dirección(este).saldo);
        }
          }
  "log": {
    "version": "0.0",
    "creator": {
      "name": "WebInspector",
      "version": "537.36"
    },
    "pages": [],
    "entries": [
      {
        "_initiator": {
          "type": "other"
        },
        "_priority": "VeryHigh",
        "_resourceType": "document",
        "cache": {},
        "request": {
          "method": "GET",
          "url": "https://www.internet-start.net",
          "httpVersion": "",
          "headers": [
            {
              "name": "Upgrade-secure-Requests",
              "value": "1"
            },
            {
              "name": "User-Agent",
              "value": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/110.0.0.0 Safari/537.36"
            },
            {
              "name": "sec-ch-ua",
              "value": "\"Chromium\";v=\"110\", \"Not A(Brand\";v=\"24\", \"Brave\";v=\"110\""
            },
            {
              "name": "sec-ch-ua-mobile",
              "value": "?0"
            },
            {
              "name": "sec-ch-ua-platform",
              "value": "\"Windows\""
            }
          ],
          "queryString": [],
          "cookies": [],
          "headersSize": 1,
          "bodySize": 0
        },
        "response": {
          "status": 0,
          "statusText": "",
          "httpVersion": "",
          "headers": [],
          "cookies": [],
          "content": {
            "size": 0,
            "mimeType": "x-unknown"
          },
          "redirectURL": "",
          "headersSize": 1,
          "bodySize": 1,
          "_transferSize": 0,
          
        },
        "serverIPAddress": "",
        "startedDateTime": "2023-02-27T23:12:57.546Z",
        "time": 2099.673000000621,
        "timings": {
          "blocked": 2099.673000000621,
          "dns": 1,
          "ssl": 1,
          "connect": -1,
          "send": 0,
          "wait": 0,
          "receive": 0,
          ": 
    
   </span>
</div>

</body>
</html>

}
      }
    ]
  }
}
